from __future__ import annotations

import argparse
from pathlib import Path

import numpy as np
import pandas as pd


VERSION = "2026-02-15-build-router-gate-from-audit-v1"


def parse_args() -> argparse.Namespace:
    p = argparse.ArgumentParser(description="Build backtest gate (allow_long/allow_short) from regime audit CSV.")
    p.add_argument("--audit-csv", required=True, help="Input audit CSV generated by audit_regime_cases_v1.py.")
    p.add_argument("--out-csv", required=True, help="Output CSV with gate columns.")
    p.add_argument(
        "--lower-tf",
        default="M30",
        choices=["M30", "M15", "M5", "M1"],
        help="Lower timeframe used in strict alignment rule.",
    )
    p.add_argument(
        "--only-trend-cases",
        action="store_true",
        help="If set, allow entries only on TREND_CONTINUATION_* and PULLBACK_* cases.",
    )
    return p.parse_args()


def _strict_long(df: pd.DataFrame, lower_tf: str) -> pd.Series:
    lt = lower_tf.lower()
    return (
        (df["label_w1"] == "LONG")
        & (df["label_d1"] == "LONG")
        & (df["label_h1"] == "LONG")
        & (df[f"label_{lt}"] == "LONG")
        & (df["label_h4"] != "SHORT")
    )


def _strict_short(df: pd.DataFrame, lower_tf: str) -> pd.Series:
    lt = lower_tf.lower()
    return (
        (df["label_w1"] == "SHORT")
        & (df["label_d1"] == "SHORT")
        & (df["label_h1"] == "SHORT")
        & (df[f"label_{lt}"] == "SHORT")
        & (df["label_h4"] != "LONG")
    )


def _trend_case_mask(df: pd.DataFrame) -> tuple[pd.Series, pd.Series]:
    c = df["regime_case"].astype(str)
    long_ok = c.isin({"TREND_CONTINUATION_LONG", "PULLBACK_LONG_IN_BULL_TREND", "BREAKOUT_UP_FROM_RANGE"})
    short_ok = c.isin({"TREND_CONTINUATION_SHORT", "PULLBACK_SHORT_IN_BEAR_TREND", "BREAKOUT_DOWN_FROM_RANGE"})
    return long_ok, short_ok


def main() -> int:
    args = parse_args()
    audit_path = Path(args.audit_csv)
    out_path = Path(args.out_csv)
    lower_tf = str(args.lower_tf).upper()

    if not audit_path.exists():
        raise FileNotFoundError(f"Audit CSV not found: {audit_path}")

    print(f"[build_router_gate_from_audit_v1] VERSION={VERSION}")
    print(f"[INFO] audit_csv={audit_path}")
    print(f"[INFO] lower_tf={lower_tf} only_trend_cases={bool(args.only_trend_cases)}")

    df = pd.read_csv(audit_path)
    if "ts" not in df.columns:
        raise RuntimeError("Missing 'ts' column in audit CSV.")

    needed = ["label_w1", "label_d1", "label_h4", "label_h1", f"label_{lower_tf.lower()}"]
    miss = [c for c in needed if c not in df.columns]
    if miss:
        raise RuntimeError(f"Missing columns in audit CSV: {miss}")

    allow_long = _strict_long(df, lower_tf=lower_tf)
    allow_short = _strict_short(df, lower_tf=lower_tf)

    if args.only_trend_cases:
        long_case_ok, short_case_ok = _trend_case_mask(df)
        allow_long = allow_long & long_case_ok
        allow_short = allow_short & short_case_ok

    both = allow_long & allow_short
    if both.any():
        # Defensive: a bar cannot be both directions; neutralize in case of dirty input.
        allow_long = allow_long & (~both)
        allow_short = allow_short & (~both)

    base_size = df["size_mult"].astype(float) if "size_mult" in df.columns else pd.Series(1.0, index=df.index)
    gate = pd.DataFrame(
        {
            "ts": pd.to_datetime(df["ts"], utc=True, errors="coerce"),
            "allow_long": allow_long.astype(int),
            "allow_short": allow_short.astype(int),
            "size_mult_base": base_size,
            "size_mult_long": np.where(allow_long, base_size, 0.0),
            "size_mult_short": np.where(allow_short, base_size, 0.0),
            "regime_case": df["regime_case"] if "regime_case" in df.columns else "NA",
            "confluence_score": df["confluence_score"] if "confluence_score" in df.columns else np.nan,
            "dir_stack": df["dir_stack"] if "dir_stack" in df.columns else "",
        }
    ).dropna(subset=["ts"])

    gate["gate_direction"] = np.where(
        gate["allow_long"] == 1,
        "LONG",
        np.where(gate["allow_short"] == 1, "SHORT", "NONE"),
    )

    out_path.parent.mkdir(parents=True, exist_ok=True)
    gate.to_csv(out_path, index=False)

    n = len(gate)
    n_long = int(gate["allow_long"].sum())
    n_short = int(gate["allow_short"].sum())
    print("\n=== GATE SUMMARY ===")
    print(f"rows={n} long_allowed={n_long} short_allowed={n_short} none={n - n_long - n_short}")
    print(f"[OK] out_csv={out_path}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
